plugins {
    id 'org.springframework.boot' version '2.1.4.RELEASE'
    id 'java'
    id 'application'

}

apply plugin: 'io.spring.dependency-management'

group = 'event-service'
version = '0.0.1'
sourceCompatibility = '1.8'


application {
    mainClassName = 'com.eventservice.EventserviceApplication'
    applicationDefaultJvmArgs = ['-Dspring.profiles.active=dev']

}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}



dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-mongodb'
    annotationProcessor 'org.springframework.boot:spring-boot-configuration-processor'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    implementation 'org.springframework.boot:spring-boot-starter-data-rest'
    compile 'org.springframework.boot:spring-boot-starter-web'
    compile 'org.springframework.boot:spring-boot-starter-amqp'
    compile group: 'com.google.code.gson', name: 'gson', version: '2.7'
    compile group: 'io.springfox',name: 'springfox-swagger2',version: '2.9.2'
    compile 'io.springfox:springfox-swagger-ui:2.9.2'


}



task getEventService << {
    println "${version}"
    removeRunningDocker()
    createEmployeeServiceContainer(version)
    initAndRun()
}



static  createEmployeeServiceContainer(version) {
    File dockerFile = new File("./Dockerfile")
    if (dockerFile.exists())
        dockerFile.delete()
    dockerFile.createNewFile()
    dockerFile.withWriter('UTF-8') { writer ->
        writer.writeLine("FROM openjdk:8-jre")
        writer.writeLine("ADD build/libs/eventservice-${version}.jar /event-service.jar")
        writer.writeLine('CMD ["java", "-jar","event-service.jar"]')
    }

}


static void initAndRun() {
    println "init and run"
    def commands = ["docker build -t eventservice:latest .",
                    "docker run -d --name eventservice -p 8081:8081 --net=hubnetwork eventservice:latest"]
    executeShell(commands)
}

static void executeShell(commands) {
    println(":executeShell:")
    commands.each {
        println ":current shell: " + it
        println it.execute().text
    }
}


static void removeRunningDocker() {
    println ":removeRunningDocker:"
    def commands = ["docker stop eventservice",
                    "docker rm -f eventservice"]
    executeShell(commands)
}
